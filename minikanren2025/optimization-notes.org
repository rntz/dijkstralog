* what seemed to help?

# MAKING ALL CONSTRUCTORS STRICT
just general good advice in Haskell.
all our laziness goes through functions anyway.

# GETTING RID OF Done IN Bound
This leaves us with just:

  data Bound k = Atleast !k | Greater !k

This seems to be most important for the use of Bound as parameter to the seek function.
WHY is this important?

# SPLITTING SEEK INTO EMPTY | YIELD

> data Seek = Seek { posn, seek }  -- out!
> data Seek = Empty | Yield !k !(Maybe k) !(Bound k -> Seek k v) -- in!

this is the easiest way to get rid of Done in Bound.
but it also seems faster than the alternative.
in particular it means we never yield a Bound from an iterator.
This restrict expressiveness: can't implement filters, b/c can't yield (Greater k).

* what haven't I tried

- CPS
- making `seek` only yield the remainder of the list
- optimizing `compare`, `max`, and `satisfies` on Bounds.

* TODO a thing I can do everywhere

in seek(), if I do leapfrog in inner join, I _know_ that the second key will be larger, so I don't need to do a three-way comparison!

* TODO another thing

InnerJoin.posn() gets called in an inner loop.
To make it faster, ensure in InnerJoin(s,t) that t is always more advanced than s.

Alternatively, make it even more like LFTJ by storing a bit of state that tells us which one is more advanced.

* Rust optimization notes
based on seek-minimal.rs
there are at least TWO effects:

if I #[inline(never)] fn gallop, then evens & odds handwritten matches my evens & odds implementation. but evens & threes is still faster handwritten, just not AS MUCH faster.

if I #[inline(always)] fn gallop, evens & odds is faster handwritten than with iterators, and evens & threes gets EVEN faster handwritten vs iterators.

GUESS 1: when gallop is inlined, it gets inlined twice handwritten but only once with iterators, and inlining twice lets the branch predictor specialize to which array I'm seeking in. (DUBIOUS: why wouldn't it get inlined twice in the iterator version?)

GUESS 2: when gallop isn't inlined, the lack of "bumping" is slowing down the iterator version.
CONFIRMED! I implemented bump() and it got faster. On evens & threes, with #[inline(never)] gallop:

|                | evens & threes | evens & odds |
|----------------+----------------+--------------|
| handwritten    | 1.28s          | 1.73s        |
| iters w/o bump |                |              |
| iters w bump   |                |              |
|----------------+----------------+--------------|
| h/nobump       |                |              |
| h/bump         |                |              |
|----------------+----------------+--------------|

  handwritten / iterators w/o bump    ~1.55x speedup
  handwritten / iterators with bump   ~1.25x speedup

but 1.25x is still a significant speedup. Hmmmm.
